{
  "name": "keyword_rank_tracker",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "seo-ranking-check",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "e7d8ea35-aa4e-49d2-8720-2fb06a341c62",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -16,
        0
      ],
      "webhookId": "642b35f8-a7f9-4445-a5f0-d2d78a3f13b7"
    },
    {
      "parameters": {
        "jsCode": "// Parse input from webhook body\nconst inputData = $input.first().json;\nconst inputBody = inputData.body || inputData;\n\nconsole.log('Received input:', inputBody);\n\n// Parse the input string: \"url\" \"keyword1\" \"keyword2\" etc.\nlet inputString;\nif (typeof inputBody === 'string') {\n  inputString = inputBody;\n} else if (inputBody.body) {\n  inputString = inputBody.body;\n} else {\n  inputString = JSON.stringify(inputBody);\n}\n\n// Split by quotes and filter out empty strings\nconst parts = inputString.match(/\"[^\"]*\"/g) || [];\nconst cleanParts = parts.map(part => part.replace(/\"/g, ''));\n\nif (cleanParts.length < 2) {\n  throw new Error('Invalid input format. Expected: \"url\" \"keyword1\" \"keyword2\" ...');\n}\n\nconst targetUrl = cleanParts[0];\nconst keywords = cleanParts.slice(1);\n\nconsole.log('Target URL:', targetUrl);\nconsole.log('Keywords:', keywords);\n\n// Create output items for each keyword\nconst outputItems = keywords.map((keyword, index) => ({\n  json: {\n    target_url: targetUrl,\n    keyword: keyword,\n    keyword_index: index\n  }\n}));\n\nreturn outputItems;"
      },
      "id": "ee5fb7b4-6223-46e3-a366-65795fae0852",
      "name": "Parse Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        0
      ]
    },
    {
      "parameters": {
        "url": "https://serpapi.com/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "api_key",
              "value": "e6ad7c56c54a24ffe431dd1b7948dab877e53e795b43e67824c9f5c4253b9bf4"
            },
            {
              "name": "engine",
              "value": "google"
            },
            {
              "name": "q",
              "value": "={{ $json.keyword }}"
            },
            {
              "name": "location",
              "value": "United States"
            },
            {
              "name": "google_domain",
              "value": "google.com"
            },
            {
              "name": "gl",
              "value": "us"
            },
            {
              "name": "hl",
              "value": "en"
            },
            {
              "name": "num",
              "value": "100"
            },
            {
              "name": "no_cache",
              "value": "true"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "5b0e3a2d-b397-46e0-b326-cf082f283845",
      "name": "SerpAPI Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        544,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Helper to extract registered base domain\nfunction getBaseDomain(urlOrDomain) {\n  let hostname = urlOrDomain.toLowerCase();\n\n  // Remove protocol and www.\n  hostname = hostname.replace(/^https?:\\/\\//, '').replace(/^www\\./, '');\n  hostname = hostname.split('/')[0];\n\n  const parts = hostname.split('.');\n\n  // Handle common second-level domains like co.uk\n  const commonSecondLevelTLDs = new Set([\n    'co.uk', 'com.au', 'gov.uk', 'ac.uk', 'org.uk', 'net.au', 'gov.au'\n  ]);\n\n  if (parts.length <= 2) {\n    return hostname; // domain.tld\n  }\n\n  const lastTwoParts = parts.slice(-2).join('.');\n  if (commonSecondLevelTLDs.has(lastTwoParts)) {\n    return parts.slice(-3).join('.');\n  }\n\n  return lastTwoParts;\n}\n\n// === CONFIGURE your TARGET_DOMAIN here ===\nconst TARGET_DOMAIN = 'n8n.io';   // adjust if needed\nconst TARGET_BASE_DOMAIN = getBaseDomain(TARGET_DOMAIN);\n\n// Fetch all incoming items (each should be SerpAPI response for a keyword)\nconst allItems = $input.all();\n\n// Aggregation variables\nlet keywordResults = [];\nlet totalPosition = 0;\nlet rankingCount = 0;\nlet top10Count = 0;\nlet top3Count = 0;\nlet page1Count = 0;\nlet notRankingCount = 0;\n\n// SERP features counters\nlet featuredSnippets = 0;\nlet peopleAlsoAsk = 0;\nlet localPack = 0;\nlet imagePack = 0;\nlet shoppingResults = 0;\n\n// Competitor tracking map: domain => { positions: [], keywords: [] }\nconst competitors = new Map();\n\nallItems.forEach((item, idx) => {\n  const apiResponse = item.json;\n\n  // Derive keyword from search parameters or fallback\n  const keyword = apiResponse?.search_parameters?.q || `keyword_${idx}`;\n\n  let foundRanking = null;\n  let rankingPosition = null;\n  let isRanking = false;\n\n  // Defensive: check organic_results array exists\n  if (Array.isArray(apiResponse.organic_results)) {\n    for (let i = 0; i < apiResponse.organic_results.length; i++) {\n      const result = apiResponse.organic_results[i];\n      // Position fallback if unavailable in result\n      const position = result.position || (i + 1);\n\n      if (!result.link) continue;\n\n      const resultBaseDomain = getBaseDomain(result.link);\n\n      if (resultBaseDomain === TARGET_BASE_DOMAIN) {\n        if (!isRanking) {  // pick first ranking occurrence only\n          foundRanking = result;\n          rankingPosition = position;\n          isRanking = true;\n\n          totalPosition += position;\n          rankingCount++;\n\n          if (position <= 3) top3Count++;\n          if (position <= 10) top10Count++;\n          if (position <= 10) page1Count++;\n        }\n      } else if (position <= 20) { // Track competitors in top 20\n        if (!competitors.has(resultBaseDomain)) {\n          competitors.set(resultBaseDomain, { domain: resultBaseDomain, positions: [], keywords: [] });\n        }\n        const data = competitors.get(resultBaseDomain);\n        data.positions.push(position);\n        data.keywords.push(keyword);\n      }\n    }\n  } else {\n    // No organic_results present\n    // Optional: console.warn(`No organic_results for keyword: ${keyword}`);\n  }\n\n  if (!isRanking) {\n    notRankingCount++;\n  }\n\n  // Count SERP features presence\n  if (apiResponse.answer_box) featuredSnippets++;\n  if (Array.isArray(apiResponse.people_also_ask) && apiResponse.people_also_ask.length > 0) peopleAlsoAsk++;\n  if (Array.isArray(apiResponse.local_results) && apiResponse.local_results.length > 0) localPack++;\n  if (Array.isArray(apiResponse.images_results) && apiResponse.images_results.length > 0) imagePack++;\n  if (Array.isArray(apiResponse.shopping_results) && apiResponse.shopping_results.length > 0) shoppingResults++;\n\n  // Assemble results for this keyword\n  keywordResults.push({\n    keyword: keyword,\n    current_rank: rankingPosition,\n    page: rankingPosition ? Math.ceil(rankingPosition / 10) : null,\n    url: foundRanking ? foundRanking.link : null,\n    title: foundRanking ? foundRanking.title : null,\n    snippet: foundRanking ? foundRanking.snippet : null,\n    featured_snippet: apiResponse.answer_box ? true : false,\n    local_pack: (Array.isArray(apiResponse.local_results) && apiResponse.local_results.length > 0)\n  });\n});\n\n// Average position calculation (rounded)\nconst averagePosition = rankingCount > 0 ? Math.round((totalPosition / rankingCount) * 10) / 10 : 0;\n\n// Process top competitors â€” only those ranking above you (positions 1-10)\nconst topCompetitorsArray = Array.from(competitors.entries())\n  .map(([domain, data]) => {\n    const avgPos = data.positions.reduce((a, b) => a + b, 0) / data.positions.length;\n    const rankingsAboveYou = data.positions.filter(pos => pos <= 10).length;\n    return {\n      domain: domain,\n      rankings_above_you: rankingsAboveYou,\n      average_position: Math.round(avgPos * 10) / 10,\n      keywords_they_rank_for: [...new Set(data.keywords)].slice(0, 5),\n    };\n  })\n  .filter(c => c.rankings_above_you > 0)\n  .sort((a, b) => b.rankings_above_you - a.rankings_above_you)\n  .slice(0, 5);\n\n// Position distribution buckets\nconst pos1to3 = keywordResults.filter(k => k.current_rank >= 1 && k.current_rank <= 3).length;\nconst pos4to10 = keywordResults.filter(k => k.current_rank >= 4 && k.current_rank <= 10).length;\nconst pos11to20 = keywordResults.filter(k => k.current_rank >= 11 && k.current_rank <= 20).length;\nconst pos21to50 = keywordResults.filter(k => k.current_rank >= 21 && k.current_rank <= 50).length;\nconst pos51to100 = keywordResults.filter(k => k.current_rank >= 51 && k.current_rank <= 100).length;\n\n// Compose final aggregated output object\nconst finalOutput = {\n  summary: {\n    total_keywords: allItems.length,\n    average_position: averagePosition,\n    top_10_rankings: top10Count,\n    top_3_rankings: top3Count,\n    page_1_rankings: page1Count,\n    not_ranking: notRankingCount,\n  },\n  keyword_rankings: keywordResults,\n  serp_features: {\n    featured_snippets: featuredSnippets,\n    people_also_ask: peopleAlsoAsk,\n    local_pack_appearances: localPack,\n    image_pack: imagePack,\n    shopping_results: shoppingResults,\n  },\n  competitors: topCompetitorsArray,\n  position_distribution: {\n    positions_1_3: pos1to3,\n    positions_4_10: pos4to10,\n    positions_11_20: pos11to20,\n    positions_21_50: pos21to50,\n    positions_51_100: pos51to100,\n    not_found: notRankingCount,\n  },\n};\n\nconsole.log('Final aggregated SEO ranking response:', finalOutput);\n\n// Return as single item with final JSON object\nreturn [{ json: finalOutput }];"
      },
      "id": "85f0c612-b77c-4e16-aa90-67070afe8a79",
      "name": "Process SerpAPI Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        736,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "1c70ed5e-d77a-4f8d-a55b-935832987ede",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        928,
        0
      ]
    },
    {
      "parameters": {
        "amount": 3,
        "unit": "seconds"
      },
      "id": "73ff291b-769a-477a-b064-e2dfcd49d1fd",
      "name": "Rate Limit Wait",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        352,
        0
      ],
      "webhookId": "919124bc-12c0-4c96-809a-fd579b2d8bce"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Rate Limit Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit Wait": {
      "main": [
        [
          {
            "node": "SerpAPI Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SerpAPI Call": {
      "main": [
        [
          {
            "node": "Process SerpAPI Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process SerpAPI Results": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "0de0b112-1ce7-4d06-8979-3e1a4ccf49e1",
  "meta": {
    "instanceId": "832574878d48053e8f4173f82ea35f0a6d5f63b9a22a16b17175c73127e82456"
  },
  "id": "Fs7XzVBOicCnoHbj",
  "tags": []
}